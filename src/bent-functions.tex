\documentclass[12pt, a4paper, reqno]{article}
\usepackage{preamble}

\title{\bf Бент-функции, использование в симметричных алгоритмах}
\date{}
\author{Долгов Александр, ФРКТ МФТИ, Б01-109а}

\begin{document}

\nocite{*}

\maketitle

\newpage
\tableofcontents

\newpage
\section{Введение}

    В современном мире большое внимание уделяется поддержанию целостности и конфиденциальности
    информации. К примеру, в крупной международной IT-компании, сотрудником которой на момент
    написания данного текста является автор, работа в некоторых отделах по исследованию и
    разработкам (R\&D) ведётся в условиях ограничений, диктуемых соображениями безопасности. Так,
    с корпоративного почтового адреса невозможно отправить сообщение во внешний мир, а доступ к
    отдельным web-сайтам заблокирован. Также жёсткие и SSD-диски, установленные в стационарных
    компьютерах и ноутбуках, зашифрованы.

    Человечеством разработано множество интереснейших алгоритмов шифрования, применение которых
    предотвращает раскрытие внутренних секретов компаний конкурентам и государственных тайн --
    иностранным разведчикам.

    Существует два основных класса таких алгоритмов: симметричные и асимметричные (с открытым
    ключом). Первые характеризуются тем, что как для шифрования, так и для дешифрования применяется
    один и тот же ключ. По построению, такой ключ не должен быть раскрыт никому, кроме участников
    обмена сообщениями. Асимметричные алгоритмы подразумевают использование пары ключей: открытого и
    закрытого. Открытый ключ нужен для шифрования сообщения и общедоступен, закрытый -- для
    дешифрования и хранится в тайне.

    В данной работе сосредоточим внимание на симметричных шифрах и том, как в некоторых из них
    используются такие интересные объекты дискретной математики как бент-функции.

\section{Бент-функции и их свойства}

    Договоримся об обозначениях. Все переменные и постоянные, встречающие далее, принадлежат полю
    $\mathbb{Z}_2 = \{0, 1\}$. Также конъюнкцию $\wedge$ для краткости будем опускать, то есть
    выражение $xy$ значит в точности то же самое, что и $x \wedge y$.

    Будем считать, что понятие булевой функции читателю известно. Рассмотрим объект, называемый
    полиномом Жегалкина.
    \begin{equation*}
        P(x_1, \ldots, x_n) = a_0 \oplus a_1 x_1 \oplus \ldots \oplus a_n x_n \oplus a_{12} x_1 x_2
        \oplus \ldots \oplus a_{1n} x_1 x_n \oplus \ldots \oplus a_{1,\ldots,n} x_1 \ldots x_n
    \end{equation*}

    Более формальной является следующая форма записи:
    \begin{equation*}
        P(x_1, \ldots, x_n) = a_0 \oplus
        \bigoplus\limits_{\substack{1 \leq i_1 < \ldots < i_k \leq n \\ k \in \{1, \ldots, n\}}}
        a_{i_1, \ldots i_k} x_{i_1} \ldots x_{i_k}
    \end{equation*}

    Существует теорема, гласящая, что любая булева функция представима в виде полинома Жегалкина.
    Доказательство может быть найдено в \cite{rubtsov}. Полином Жегалкина, особенно в иностранной
    литературе, также называют алгебраической нормальной формой (АНФ) булевой функции.

    Приведём некоторые вспомогательные определения, необходимые для введения понятия бент-функции.

    \textbf{Определение:} булева функция называется \textit{линейной}, если конъюнкты её аргументов,
    входящие в полином Жегалкина, имеют длину не более, чем 1. Формально это записывается так:
    \begin{equation*}
        \exists a_0, \ldots, a_n \in \mathbb{Z}_2:
        f(x_1, \ldots, x_n) = a_0 \oplus a_1 x_1 \oplus \ldots \oplus a_n x_n
    \end{equation*}

    \textit{Примеры}:
    \begin{itemize}
        \item Отрицание $\overline{x} = 1 \oplus x$ является линейной булевой функцией;
        \item Дизъюнкция $x \vee y = x \oplus y \oplus xy$ -- не является.
    \end{itemize}

    \textbf{Определение:} \textit{весом Хэмминга} называется число единиц в двоичном слове.

    \textbf{Определение:} \textit{расстоянием Хэмминга} между двумя двоичными словами одинаковой
    длины называется число позиций, в которых соответствующие символы этих слов различны;
    обозначается расстояние Хэмминга как $d(x, y)$.

    Альтернативно можно определить расстояние Хэмминга как вес Хэмминга слова $x \oplus y$, где $x$,
    $y$ -- данные двоичные слова.

    \textit{Примеры}:
    \begin{itemize}
        \item $d(0110, 0111) = 1$
        \item $d(0110, 1001) = 4$
    \end{itemize}

    Возможно ввести расстояние Хэмминга между булевыми функциями фиксированного числа аргументов как
    расстояние между векторами их значений. Очевидно, что для такого определения нужно зафиксировать
    порядок перебора аргументов. Обычно в качестве такового выступает лексикографический порядок.

    Далее, расстояние от фиксированной булевой функции до некоторого множества булевых функций можно
    ввести, как это обычно делается, через точную верхнюю грань расстояний до каждого из элементов
    множества. В случае, если множество булевых функций конечно, что имеет место при фиксированном
    числе аргументов, точная верхняя грань совпадает с максимумом.

    \textbf{Определение:} \textit{нелинейностью} $N_f$ булевой функции $f$ называется расстояние
    Хэмминга от неё до множества линейных булевых функций с тем же числом аргументов.

    \textbf{Определение:} \textit{бент-функцией} называется такая булева функция с чётным числом
    аргументов, что её нелинейность максимальная.

    В русскоязычной литературе встречается также более широкое понятие \textit{максимально
    нелинейной} функции, которое совпадает с определением бент-функции за исключением требования
    чётности числа аргументов, которое не накладывается. Таким образом, бент-функции образуют
    подмножество в множестве максимально нелинейных функций. Поскольку максимально нелинейный
    функции, не являющиеся бент-функциями, изучены хуже, например, неизвестно выражение для
    нелинейности, далее будем рассматривать только бент-функции.

    В статье \cite{rothaus} Оскара Ротхауса, автора термина \textit{бент-функция}, доказано
    несколько свойств этих функций. Приведём некоторые из них, используемые в дальнейшем.

    \textbf{Свойство 1:} вес Хэмминга вектора значений бент-функции $n$ аргументов принимает одно из
    двух значений:
    \begin{equation*}
        2^{n - 1} + 2^{\frac{n}{2} - 1}\text{ или }2^{n - 1} - 2^{\frac{n}{2} - 1}
    \end{equation*}

    \textbf{Свойство 2:} бент-функций $n$ аргументов существует не меньше, чем
    $2^{2^{\frac{n}{2}}}(2^{\frac{n}{2}})!$.

\section{Симметричные шифры}

    Рассмотрим, что представляют из себя симметричные шифры. Они делятся на две группы: блочные и
    поточные.

    Принцип работы поточных шифров следующий. Ключ выступает в роли начального состояния (seed)
    генератора псевдослучаных чисел. Генерируемая последовательность называется \textit{гаммой}.
    Шифрование сводится к применению некоторой операции над символами открытого текста и числами
    гаммы. Такой операцией обычно является побитовое \textit{исключающее или} (XOR), а под символами
    можно понимать как байты, так и биты. Более детально поточные шифры рассматривать не будем,
    поскольку они не являются объектом наших интересов. Информация о них приведена лишь для полноты
    картины.

    Теперь погрузимся в блочные шифры. Открытый текст в них, как ясно из названия, разбивается на
    блоки одинакового размера. Если последний блок имеет размер меньший, чем все предыдущие, его
    некоторым образом дополняют до размеры предыдущих. Далее, над каждым блоком проводится череда
    однотипных трансформаций -- \textit{раундов}. Из ключа шифрования по определённому закону,
    называемому \textit{расписанием ключей}, получают \textit{итерационные ключи} -- по одному на
    каждый раунд. Говоря формально, раунд представляет собой применение к блоку и итерационному
    ключу некоторой функции -- \textit{раундовой функции}, возвращающей блок для следующего раунда.
    Результаты последовательности раундов, применённых к каждому блоку, объединяются (сцепляются) в
    итоговый шифротекст.

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.8\textwidth]{block-cipher.png}
        \caption{Принцип работы блочного шифра}
    \end{figure}

    Из описания ясно, что блочные алгоритмы имеют несколько точек кастомизации:
    \begin{itemize}
        \item Размер блока
        \item Размер ключа
        \item Число раундов
        \item Функция расписания ключей
        \item Функция сцепления блоков
        \item Раундовая функция
    \end{itemize}

    Размер блока принято выбирать равным степени двойки. Как пишут авторы шифра CAST, о котором речь
    пойдёт далее, размер блока должен быть достаточно велик, чтобы препятствовать атаке, основанной
    на парадоксе дней рождения, и не настолько большим, чтобы значительно усложнить реализацию (в
    том числе в железе) \cite{cast}. Именно поэтому в действительности вопрос выбора размера блока
    не представляет большого интереса, и многие современные шифры используют блоки в 64 или 128
    битов. Так, например, алгоритмы DES, ГОСТ 28147-89, RC2, Blowfish и CAST применяют 64-битные
    блоки, а алгоритмы "Кузнечик"\ и AES -- 128-битные.

    Аналогичная ситуация имеет место и с размером ключа. В приведённых выше алгоритмах длина ключа
    варьируется от 40 (минимум для CAST) до 448 битов (максимум для Blowfish). Такие алгоритмы, как
    Blowfish, позиционируются как шифры с переменной длиной ключа.

    Вопрос выбора функций расписания ключей и сцепления блоков представляет отдельный интерес, но
    в данной работе окажется нерассмотренным.

    Как удалось выяснить автору, бент-функциям было найдено применение в алгоритмах раундовой
    функции. Поэтому далее детально рассмотрим устройство раундовой функции одного конкретного
    шифра.

\section{Шифр CAST и применение в нём бент-функций}

    \begin{wrapfigure}{r}{0.25\textwidth}
        \centering
        \includegraphics[width=0.25\textwidth]{feistel.png}
        \caption{Сеть Фейстеля}
    \end{wrapfigure}

    В 1997 году К.Адамсом и С.Таваресом был предложен алгоритм блочного шифрования, известный как
    CAST. Название получено из первых букв имён и фамилий авторов: Carlisle Adams, Stafford Tavares.
    Отметим, что алгоритм одобрен для использования правительством Канады.

    Каждый раунд в алгоритме CAST сводится к применению ячейки Фейстеля. Это очень простая
    конструкция, состоящая из двух этапов. Первый принимает на вход блок длиной $2n$ битов и
    разбивает его на две равные части: L и R, -- поэтому вход ячейки Фейстеля принято сразу
    записывать в виде $(L, R)$. Выходом первого этапа является блок $(L \oplus F_i(K_i, R), R)$, где
    $F_i$ -- некоторая функция, зависящая от раунда, $K_i$ -- итерационный ключ. Второй этап
    заключается в том, что левая и правая части блока меняются местами. Таким образом, ячейка
    Фейстеля -- отображение
    \begin{equation*}
        (L, R) \to (R, L \oplus F(K_i, R))
    \end{equation*}

    Ячейка Фейстеля последнего раунда в алгоритме CAST не выполняет перестановку левой и правой
    частей. Последовательность ячеек Фейстеля образует конструкцию, называемую
    \textit{сетью Фейстеля}.

    Теперь рассмотрим реализацию функций $F_i$ в шифре CAST, но для этого потребуется ввести новое
    понятие.

    \textbf{Определение:} \textit{S-блоком} (блоком подстановок) называется нелинейная булева
    вектор-функция:
    \begin{equation*}
        S: \mathbb{Z}_2^m \to \mathbb{Z}_2^n
    \end{equation*}

    Под размером $S$-блока понимаем число аргументов и размерность результата.

    Любую вектор-функцию, возвращающую $n$-мерный результат, можно представить как $n$ функций
    (компонентов), возвращающих одномерный результат. Учитывая это замечание, введём также ещё одно
    понятие.

    \textbf{Определение:} \textit{идеальным} называется $S$-блок, компоненты которого являются
    бент-функциями, а также любая линейная комбинация выходных битов является бент-функцией от
    входных.

    Шифр CAST использует 4 $S$-блока размером $8 \times 32$ битов. Размер блока данных в шифре,
    составляет 64 бита. Учитывая описанную выше схему работы ячейки Фейстеля, понимаем, что на вход
    функции $F_i$ приходит 32 бита блока открытого текста.

    \begin{wrapfigure}{r}{0.3\textwidth}
        \centering
        \includegraphics[width=0.3\textwidth]{round-func.png}
        \caption{Функция $F_i$}
    \end{wrapfigure}

    Алгоритм, описывающий действие функции $F_i$ следующий:
    \begin{enumerate}
        \item 32-битное число и итерационный ключ $K_i$ поступают на вход операции \textbf{a},
              возвращающей 32 бита.
        \item Результат операции \textbf{a} делится на 4 равные части по 8 битов.
        \item Каждая 8-битная часть поступает на вход одного из $S$-блоков размером
              $8 \times 32$ битов: $S_1$, $S_2$, $S_3$ и $S_4$; в результате получаем 4 32-битных
              значения.
        \item Значения, полученные от блоков $S_1$ и $S_2$, поступают на вход операции \textbf{b},
              возвращающей 32-битное значение.
        \item Значение, полученное на предыдущем шаге, и значение, полученное от блока $S_3$,
              поступают на вход операции \textbf{c}, возвращающей 32-битное значение.
        \item Значение, полученное на предыдущем шаге, и значение, полученное от блока $S_4$,
              поступают на вход операции \textbf{d}, возвращающей 32-битное значение, являющее
              возвращающим значением функции $F_i$.
    \end{enumerate}

    Как отмечают авторы алгоритма \cite{cast}, все операции \textbf{a}, \textbf{b}, \textbf{c} и
    \textbf{d} являются операцией XOR, хотя могут быть заменены и на более сложные функции.

    Итак, раундовая функция шифра CAST подробно описана. Осталось лишь выяснить, как бент-функции
    влияют на свойства $S$-блоков и как это отражается на свойствах раундовой функции.

    Предварительно рассмотрим основные классы атак на блочные шифры. Таковыми являются линейный и
    дифференциальный криптоанализ.

    \textbf{Определение:} \textit{линейный криптоанализ} -- метод криптоанализа, основанный на
    поиске линейных приближений шифра.

    \textbf{Определение:} \textit{дифференциальный криптоанализ} -- метод криптоанализа, основанный
    на исследовании того, как в ходе шифрования изменяется разность пары шифруемых значений (под
    разностью чаще всего понимается побитовое \textit{исключающее или} (XOR)).

    Для защиты от линейного криптоанализа шифр должны удовлетворять \textit{строгому лавинному
    критерию}, то есть при изменении одного из битов открытого текста каждый бит шифротекста
    изменяется с вероятностью $\dfrac{1}{2}$.

    Для защиты от дифференциального криптоанализа необходимо увеличивать число раундов. В связи с
    этим далее к дифференциальному криптоанализу возвращаться не будем.

    Рассмотрим, наконец, построение $S$-блоков в алгоритме CAST. Строятся они так:
    \begin{enumerate}
        \item Выбираем 32 различные бент-функции 8 аргументов (это возможно в силу приводимой ранее
              оценки снизу числа бент-функций) так, чтобы
        \begin{itemize}
            \item любая их линейная комбинация давала сильно нелинейную функцию, практически
                  удовлетворяющую строгому лавинному критерию;
            \item половина этих функций имела один вес Хэмминга, вторая -- другой (как было отмечено
                  ранее, вес Хэмминга бент-функций принимает одно из двух значений);
        \end{itemize}
        \item Составим матрицу, столбцы которой являются векторам значений выбранных бент-функций.
              Размер такой матрицы: $2^8 \times 32$.
        \item Проверим, что все строки матрицы различны, а также что вес Хэмминга каждой строки и
              расстояние Хэмминга между парами строк близки к $\dfrac{32}{2} = 16$.
        \item Если условия предыдущего шага не соблюдены, возвращаемся к первому шару.
    \end{enumerate}

    \textit{Замечание 1}: после успешной генерации одного $S$-блока при генерации каждого нового
    должны быть взяты новые бент-функции.

    \textit{Замечание 2}: блоки, построенные описанным методом, почти удовлетворяют определению
    идеального (не все линейные комбинации обязаны быть бент-функциями), что делает их близкими к
    идеальным.

    \textit{Замечание 3}: как утверждают авторы шифра CAST, построить один $S$-блок возможно за
    несколько недель вычислений на обычном компьютере; учитывая, что статья выпущена в 1997 году,
    на момент написания данного текста вычисления должны занять меньше времени.

    Построение $S$-блоков таким методом позволяет им обладать набором свойств, делающих шифр стойким
    к линейному криптоанализу:
    \begin{itemize}
        \item выполнение строгого лавинного критерия;
        \item выполнение критерия независимости битов (любые два бита шифротекста меняются
              независимо при изменении любого бита открытого текста) с высокой точностью.
    \end{itemize}

    Доказательство может быть найдено в \cite{cast}. Идейно обладание этими свойствами объясняется
    тем, что присутствие бент-функций в конструкции $S$-блоков сводит на нет линейную аппроксимацию
    шифра, поскольку бент-функции наиболее удалены от линейных в метрике расстояния Хэмминга.

\section{Выводы}

    Итак, были изучены принципы построения симметричных и особенно блочных шифров, рассмотрено,
    какие преимущества имеют шифры, использующие бент-функции, на примере алгоритма CAST.

\printbibliography[heading=bibintoc, title={Список литературы}]

\end{document}
